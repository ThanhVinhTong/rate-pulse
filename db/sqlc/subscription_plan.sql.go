// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscription_plan.sql

package db

import (
	"context"
	"database/sql"
)

const createSubscriptionPlan = `-- name: CreateSubscriptionPlan :one
INSERT INTO subscription_plans (
    plan_name,
    plan_price,
    historical_days,
    rate_limit_per_day,
    features,
    is_active
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING plan_id, plan_name, plan_price, historical_days, rate_limit_per_day, features, is_active, created_at, updated_at
`

type CreateSubscriptionPlanParams struct {
	PlanName        string
	PlanPrice       string
	HistoricalDays  int32
	RateLimitPerDay int32
	Features        sql.NullString
	IsActive        sql.NullBool
}

func (q *Queries) CreateSubscriptionPlan(ctx context.Context, arg CreateSubscriptionPlanParams) (SubscriptionPlan, error) {
	row := q.db.QueryRowContext(ctx, createSubscriptionPlan,
		arg.PlanName,
		arg.PlanPrice,
		arg.HistoricalDays,
		arg.RateLimitPerDay,
		arg.Features,
		arg.IsActive,
	)
	var i SubscriptionPlan
	err := row.Scan(
		&i.PlanID,
		&i.PlanName,
		&i.PlanPrice,
		&i.HistoricalDays,
		&i.RateLimitPerDay,
		&i.Features,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSubscriptionPlan = `-- name: DeleteSubscriptionPlan :exec
DELETE FROM subscription_plans
WHERE plan_id = $1
`

func (q *Queries) DeleteSubscriptionPlan(ctx context.Context, planID int32) error {
	_, err := q.db.ExecContext(ctx, deleteSubscriptionPlan, planID)
	return err
}

const getActiveSubscriptionPlans = `-- name: GetActiveSubscriptionPlans :many
SELECT plan_id, plan_name, plan_price, historical_days, rate_limit_per_day, features, is_active, created_at, updated_at FROM subscription_plans
WHERE is_active = true
ORDER BY plan_price ASC
`

func (q *Queries) GetActiveSubscriptionPlans(ctx context.Context) ([]SubscriptionPlan, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSubscriptionPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPlan
	for rows.Next() {
		var i SubscriptionPlan
		if err := rows.Scan(
			&i.PlanID,
			&i.PlanName,
			&i.PlanPrice,
			&i.HistoricalDays,
			&i.RateLimitPerDay,
			&i.Features,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSubscriptionPlans = `-- name: GetAllSubscriptionPlans :many
SELECT plan_id, plan_name, plan_price, historical_days, rate_limit_per_day, features, is_active, created_at, updated_at FROM subscription_plans
ORDER BY plan_price ASC
`

func (q *Queries) GetAllSubscriptionPlans(ctx context.Context) ([]SubscriptionPlan, error) {
	rows, err := q.db.QueryContext(ctx, getAllSubscriptionPlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionPlan
	for rows.Next() {
		var i SubscriptionPlan
		if err := rows.Scan(
			&i.PlanID,
			&i.PlanName,
			&i.PlanPrice,
			&i.HistoricalDays,
			&i.RateLimitPerDay,
			&i.Features,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionPlanByID = `-- name: GetSubscriptionPlanByID :one
SELECT plan_id, plan_name, plan_price, historical_days, rate_limit_per_day, features, is_active, created_at, updated_at FROM subscription_plans
WHERE plan_id = $1 LIMIT 1
`

func (q *Queries) GetSubscriptionPlanByID(ctx context.Context, planID int32) (SubscriptionPlan, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionPlanByID, planID)
	var i SubscriptionPlan
	err := row.Scan(
		&i.PlanID,
		&i.PlanName,
		&i.PlanPrice,
		&i.HistoricalDays,
		&i.RateLimitPerDay,
		&i.Features,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSubscriptionPlanByName = `-- name: GetSubscriptionPlanByName :one
SELECT plan_id, plan_name, plan_price, historical_days, rate_limit_per_day, features, is_active, created_at, updated_at FROM subscription_plans
WHERE plan_name = $1 LIMIT 1
`

func (q *Queries) GetSubscriptionPlanByName(ctx context.Context, planName string) (SubscriptionPlan, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionPlanByName, planName)
	var i SubscriptionPlan
	err := row.Scan(
		&i.PlanID,
		&i.PlanName,
		&i.PlanPrice,
		&i.HistoricalDays,
		&i.RateLimitPerDay,
		&i.Features,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSubscriptionPlan = `-- name: UpdateSubscriptionPlan :one
UPDATE subscription_plans
SET
    plan_name = COALESCE($1, plan_name),
    plan_price = COALESCE($2, plan_price),
    historical_days = COALESCE($3, historical_days),
    rate_limit_per_day = COALESCE($4, rate_limit_per_day),
    features = COALESCE($5, features),
    is_active = COALESCE($6, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE plan_id = $7
RETURNING plan_id, plan_name, plan_price, historical_days, rate_limit_per_day, features, is_active, created_at, updated_at
`

type UpdateSubscriptionPlanParams struct {
	PlanName        sql.NullString
	PlanPrice       sql.NullString
	HistoricalDays  sql.NullInt32
	RateLimitPerDay sql.NullInt32
	Features        sql.NullString
	IsActive        sql.NullBool
	PlanID          int32
}

func (q *Queries) UpdateSubscriptionPlan(ctx context.Context, arg UpdateSubscriptionPlanParams) (SubscriptionPlan, error) {
	row := q.db.QueryRowContext(ctx, updateSubscriptionPlan,
		arg.PlanName,
		arg.PlanPrice,
		arg.HistoricalDays,
		arg.RateLimitPerDay,
		arg.Features,
		arg.IsActive,
		arg.PlanID,
	)
	var i SubscriptionPlan
	err := row.Scan(
		&i.PlanID,
		&i.PlanName,
		&i.PlanPrice,
		&i.HistoricalDays,
		&i.RateLimitPerDay,
		&i.Features,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
